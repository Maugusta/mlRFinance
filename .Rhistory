#Cost parameter - Mean Equation
Cmean<-seq(0.01,0.1,length.out = 5)
#Epsilon parameter - Mean Equation
epsilonMean <-seq(0.04,0.5,length.out=7)
#Kernel mean equation
kernelMean <- "Gaussian"
#parameters kernel - Mean Equation
parmsMean <-matrix(c(1.0,
1.5,
2.0),ncol=1,nrow=3,byrow=T)
#Cost parameter - Volatility Equation
Cvola <-seq(0.5,0.7,length.out = 4)
#Epsilon parameter - Volatility Equation
epsilonVola <-seq(0.01,0.9,length.out=4)
#Kernel - Volatility Equation
kernelVolat <- "Polynomial"
#parameters kernel - Volatility Equation
parmsVola <- matrix(c(2,1,
1.5,5,
2.0,7),ncol=2,nrow=3,byrow=T)
#Do the cross-validation
teste<-GarchSVR(train,valid,Cmean,epsilonMean,kernelMean,parmsMean,
Cvola,epsilonVola,kernelVolat,parmsVola)
e.model<-runif(1000,-1,1)
e.bench<-runif(1000,-1,1)
ceil(length(e.model)^(1/3))
ceiling(length(e.model)^(1/3))
help(ceiling)
d.diff <- e.model-e.bench
d.bar <- mean(d.diff)
auto.cov<- acf(d.diff, "covariance", plot = F)$acf
help(acf)
auto.cov[1] <- var(d.diff)
M=floor(length(e.model)^(1/3))
M
M=ceiling(length(e.model)^(1/3))
M
var <- var(d.diff) +2*sum(auto.cov)
T <- length(e.model)
DM <- d.bar/sqrt(var/T)
#MlRFinance
rm(list=ls())
library(mlRFinance)
library(quantmod)
#Cria um novo ambiente para armazenar os dados
stockData <- new.env()
#Especifica as datas de interesse
startDate = as.Date("2011-01-01")
endDate = as.Date("2011-12-31")
#Obtêm os dados do ativo PETR4 e PETR3
getSymbols("^BVSP", src="yahoo",from=startDate,to=endDate)
#Calcula o log-retorno
retorno<-na.omit(diff(log(Cl(BVSP))))
#Training set
train <- as.numeric(retorno[1:180])
#Validation set
valid <- as.numeric(retorno[181:216])
#Cost parameter - Mean Equation
Cmean<-seq(0.01,10)
#Epsilon parameter - Mean Equation
epsilonMean <-seq(0.04,0.5,length.out=7)
#Kernel mean equation
kernelMean <- "Gaussian"
#parameters kernel - Mean Equation
parmsMean <-matrix(c(1.0,
1.5,
2.0),ncol=1,nrow=3,byrow=T)
#Cost parameter - Volatility Equation
Cvola <-seq(0.5,0.7,length.out = 4)
#Epsilon parameter - Volatility Equation
epsilonVola <-seq(0.01,0.9,length.out=4)
#Kernel - Volatility Equation
kernelVolat <- "Polynomial"
#parameters kernel - Volatility Equation
parmsVola <- matrix(c(2,1,
1.5,5,
2.0,7),ncol=2,nrow=3,byrow=T)
Cmean <- 0.01
epsilonMean <- 0.04
kernelMean <- "Gaussian"
parmsMean <- 1
Cvola <- 0.5
epsilonVola <- 0.01
kernelVolat <- "Polynomial"
parmsVola <- c(2,1)
svm<-GARCHCSVRL1(train, valid, Cmean, epsilonMean, Cvola, epsilonVola, kernelMean, parmsMean, kernelVolat, parmsVola)
svm$PredictedMeanTraining
Cmean <- 0.02
epsilonMean <- 0.04
kernelMean <- "Gaussian"
parmsMean <- 1
Cvola <- 0.5
epsilonVola <- 0.01
kernelVolat <- "Polynomial"
parmsVola <- c(2,1)
svm<-GARCHCSVRL1(train, valid, Cmean, epsilonMean, Cvola, epsilonVola, kernelMean, parmsMean, kernelVolat, parmsVola)
svm$PredictedMeanTraining
Cmean <- 0.03
epsilonMean <- 0.04
kernelMean <- "Gaussian"
parmsMean <- 1
Cvola <- 0.5
epsilonVola <- 0.01
kernelVolat <- "Polynomial"
parmsVola <- c(2,1)
svm<-GARCHCSVRL1(train, valid, Cmean, epsilonMean, Cvola, epsilonVola, kernelMean, parmsMean, kernelVolat, parmsVola)
svm$PredictedMeanTraining
Cmean <- 0.04
epsilonMean <- 0.04
kernelMean <- "Gaussian"
parmsMean <- 1
Cvola <- 0.5
epsilonVola <- 0.01
kernelVolat <- "Polynomial"
parmsVola <- c(2,1)
svm<-GARCHCSVRL1(train, valid, Cmean, epsilonMean, Cvola, epsilonVola, kernelMean, parmsMean, kernelVolat, parmsVola)
svm$PredictedMeanTraining
Cmean <- 0.05
epsilonMean <- 0.04
kernelMean <- "Gaussian"
parmsMean <- 1
Cvola <- 0.5
epsilonVola <- 0.01
kernelVolat <- "Polynomial"
parmsVola <- c(2,1)
svm<-GARCHCSVRL1(train, valid, Cmean, epsilonMean, Cvola, epsilonVola, kernelMean, parmsMean, kernelVolat, parmsVola)
svm$PredictedMeanTraining
Cmean <- 0.05
epsilonMean <- 0.01
kernelMean <- "Gaussian"
parmsMean <- 1
Cvola <- 0.5
epsilonVola <- 0.01
kernelVolat <- "Polynomial"
parmsVola <- c(2,1)
svm<-GARCHCSVRL1(train, valid, Cmean, epsilonMean, Cvola, epsilonVola, kernelMean, parmsMean, kernelVolat, parmsVola)
svm$PredictedMeanTraining
Cmean <- 0.05
epsilonMean <- 0.02
kernelMean <- "Gaussian"
parmsMean <- 1
Cvola <- 0.5
epsilonVola <- 0.01
kernelVolat <- "Polynomial"
parmsVola <- c(2,1)
svm<-GARCHCSVRL1(train, valid, Cmean, epsilonMean, Cvola, epsilonVola, kernelMean, parmsMean, kernelVolat, parmsVola)
svm$PredictedMeanTraining
Cmean <- 0.05
epsilonMean <- 0.10
kernelMean <- "Gaussian"
parmsMean <- 1
Cvola <- 0.5
epsilonVola <- 0.01
kernelVolat <- "Polynomial"
parmsVola <- c(2,1)
svm<-GARCHCSVRL1(train, valid, Cmean, epsilonMean, Cvola, epsilonVola, kernelMean, parmsMean, kernelVolat, parmsVola)
svm$PredictedMeanTraining
Cvola <- 0.7
epsilonVola <- 0.01
kernelVolat <- "Polynomial"
parmsVola <- c(2,1)
svm<-GARCHCSVRL1(train, valid, Cmean, epsilonMean, Cvola, epsilonVola, kernelMean, parmsMean, kernelVolat, parmsVola)
svm$PredictedMeanTraining
Cvola <- 0.7
epsilonVola <- 0.1
kernelVolat <- "Polynomial"
parmsVola <- c(2,1)
svm<-GARCHCSVRL1(train, valid, Cmean, epsilonMean, Cvola, epsilonVola, kernelMean, parmsMean, kernelVolat, parmsVola)
svm$PredictedMeanTraining
Cvola <- 0.7
epsilonVola <- 0.1
kernelVolat <- "Polynomial"
parmsVola <- c(3,1)
svm<-GARCHCSVRL1(train, valid, Cmean, epsilonMean, Cvola, epsilonVola, kernelMean, parmsMean, kernelVolat, parmsVola)
svm$PredictedMeanTraining
#MlRFinance
rm(list=ls())
library(mlRFinance)
library(quantmod)
#Cria um novo ambiente para armazenar os dados
stockData <- new.env()
#Especifica as datas de interesse
startDate = as.Date("2011-01-01")
endDate = as.Date("2011-12-31")
#Obtêm os dados do ativo PETR4 e PETR3
getSymbols("^BVSP", src="yahoo",from=startDate,to=endDate)
#Calcula o log-retorno
retorno<-na.omit(diff(log(Cl(BVSP))))
#Training set
train <- as.numeric(retorno[1:180])
#Validation set
valid <- as.numeric(retorno[181:216])
#Cost parameter - Mean Equation
Cmean<-seq(0.01,0.05,length.out = 5)
#Epsilon parameter - Mean Equation
epsilonMean <-seq(0.04,0.1,length.out=7)
#Kernel mean equation
kernelMean <- "Gaussian"
#parameters kernel - Mean Equation
parmsMean <-matrix(c(1.0,
1.5,
2.0),ncol=1,nrow=3,byrow=T)
#Cost parameter - Volatility Equation
Cvola <-seq(0.5,0.7,length.out = 4)
#Epsilon parameter - Volatility Equation
epsilonVola <-seq(0.01,0.1,length.out=4)
#Kernel - Volatility Equation
kernelVolat <- "Polynomial"
#parameters kernel - Volatility Equation
parmsVola <- matrix(c(2,1,
3,5,
4,7),ncol=2,nrow=3,byrow=T)
teste<-GarchSVR(train,valid,Cmean,epsilonMean,kernelMean,parmsMean,
Cvola,epsilonVola,kernelVolat,parmsVola)
install.packages("tcltk")
library(mlRFinance)
#MlRFinance
rm(list=ls())
library(mlRFinance)
library(quantmod)
#Cria um novo ambiente para armazenar os dados
stockData <- new.env()
#Especifica as datas de interesse
startDate = as.Date("2011-01-01")
endDate = as.Date("2011-12-31")
#Obtêm os dados do ativo PETR4 e PETR3
getSymbols("^BVSP", src="yahoo",from=startDate,to=endDate)
#Calcula o log-retorno
retorno<-na.omit(diff(log(Cl(BVSP))))
#Training set
train <- as.numeric(retorno[1:180])
#Validation set
valid <- as.numeric(retorno[181:216])
#Cost parameter - Mean Equation
Cmean<-seq(0.01,0.05,length.out = 5)
#Epsilon parameter - Mean Equation
epsilonMean <-seq(0.04,0.1,length.out=7)
#Kernel mean equation
kernelMean <- "Gaussian"
#parameters kernel - Mean Equation
parmsMean <-matrix(c(1.0,
1.5,
2.0),ncol=1,nrow=3,byrow=T)
#Cost parameter - Volatility Equation
Cvola <-seq(0.5,0.7,length.out = 4)
#Epsilon parameter - Volatility Equation
epsilonVola <-seq(0.01,0.1,length.out=4)
#Kernel - Volatility Equation
kernelVolat <- "Polynomial"
#parameters kernel - Volatility Equation
parmsVola <- matrix(c(2,1,
3,5,
4,7),ncol=2,nrow=3,byrow=T)
teste<-GarchSVR(train,valid,Cmean,epsilonMean,kernelMean,parmsMean,
Cvola,epsilonVola,kernelVolat,parmsVola)
#MlRFinance
rm(list=ls())
library(mlRFinance)
library(quantmod)
#Cria um novo ambiente para armazenar os dados
stockData <- new.env()
#Especifica as datas de interesse
startDate = as.Date("2011-01-01")
endDate = as.Date("2011-12-31")
#Obtêm os dados do ativo PETR4 e PETR3
getSymbols("^BVSP", src="yahoo",from=startDate,to=endDate)
#Calcula o log-retorno
retorno<-na.omit(diff(log(Cl(BVSP))))
#Training set
train <- as.numeric(retorno[1:180])
#Validation set
valid <- as.numeric(retorno[181:216])
#Cost parameter - Mean Equation
Cmean<-seq(0.01,0.05,length.out = 5)
#Epsilon parameter - Mean Equation
epsilonMean <-seq(0.04,0.1,length.out=7)
#Kernel mean equation
kernelMean <- "Gaussian"
#parameters kernel - Mean Equation
parmsMean <-matrix(c(1.0,
1.5,
2.0),ncol=1,nrow=3,byrow=T)
#Cost parameter - Volatility Equation
Cvola <-seq(0.5,0.7,length.out = 4)
#Epsilon parameter - Volatility Equation
epsilonVola <-seq(0.01,0.1,length.out=4)
#Kernel - Volatility Equation
kernelVolat <- "Polynomial"
#parameters kernel - Volatility Equation
parmsVola <- matrix(c(2,1,
3,5,
4,7),ncol=2,nrow=3,byrow=T)
#Do the cross-validation
train<-train
valid<-valid
Cm<-Cmean
epsilonM<-epsilonMean
kernel<-kernelMean
parmMat<-parmsMean
Cg<-Cvola
epsilonG<-epsilonVola
kernelGarch<-kernelVolat
parmMatGarch<-parmsVola
#Create the matrix with all combinations between C, epsilon e parms
matAll <- expand.grid(Cm,epsilonM,Cg,epsilonG)
#Combination with parms (Mean Equation)
matAll<-merge(matAll,parmMat)
#Insert names
colnames(matAll)<-c("Cm","epsilonM","Cg","epsilonG",
paste0("ParmM",seq(0,ncol(parmMat)-1)))
#Parameters
matAll <- merge(matAll,parmMatGarch)
#Insert names
colnames(matAll)<-c("Cm","epsilonM","Cg","epsilonG",
paste0("ParmM",seq(0,ncol(parmMat)-1)),
paste0("ParmG",seq(0,ncol(parmMatGarch)-1)))
i<-1
#Cost - Mean Equation
C0m<-matAll$Cm[i]
#Epsilon - Mean Equation
eps0m<-matAll$epsilonM[i]
#Parms Mean
parmsM<-as.numeric(matAll[i,5:(4+ncol(parmMat))])
#Cost - Garch Equation
C0g<-matAll$Cg[i]
#Epsilon - Garch Equation
eps0g<-matAll$epsilonG[i]
#Parms Garch
parmsG<-as.numeric(matAll[i,(5+ncol(parmMat)):(3+ncol(parmMat)+ncol(parmMat))])
#Training the machine
svr<-GARCHCSVRL1(train, valid, C0m, eps0m,
C0g, eps0g,
kernel, parmsM,
kernelGarch, parmsG)
nrow(matAll)
i<-2
#Cost - Mean Equation
C0m<-matAll$Cm[i]
#Epsilon - Mean Equation
eps0m<-matAll$epsilonM[i]
#Parms Mean
parmsM<-as.numeric(matAll[i,5:(4+ncol(parmMat))])
#Cost - Garch Equation
C0g<-matAll$Cg[i]
#Epsilon - Garch Equation
eps0g<-matAll$epsilonG[i]
#Parms Garch
parmsG<-as.numeric(matAll[i,(5+ncol(parmMat)):(3+ncol(parmMat)+ncol(parmMat))])
#Training the machine
svr<-GARCHCSVRL1(train, valid, C0m, eps0m,
C0g, eps0g,
kernel, parmsM,
kernelGarch, parmsG)
library(mlRFinance)
#MlRFinance
rm(list=ls())
library(mlRFinance)
library(quantmod)
#Cria um novo ambiente para armazenar os dados
stockData <- new.env()
#Especifica as datas de interesse
startDate = as.Date("2011-01-01")
endDate = as.Date("2011-12-31")
#Obtêm os dados do ativo PETR4 e PETR3
getSymbols("^BVSP", src="yahoo",from=startDate,to=endDate)
#Calcula o log-retorno
retorno<-na.omit(diff(log(Cl(BVSP))))
#Training set
train <- as.numeric(retorno[1:180])
#Validation set
valid <- as.numeric(retorno[181:216])
#Cost parameter - Mean Equation
Cmean<-seq(0.01,0.05,length.out = 5)
#Epsilon parameter - Mean Equation
epsilonMean <-seq(0.04,0.1,length.out=7)
#Kernel mean equation
kernelMean <- "Gaussian"
#parameters kernel - Mean Equation
parmsMean <-matrix(c(1.0,
1.5,
2.0),ncol=1,nrow=3,byrow=T)
#Cost parameter - Volatility Equation
Cvola <-seq(0.5,0.7,length.out = 4)
#Epsilon parameter - Volatility Equation
epsilonVola <-seq(0.01,0.1,length.out=4)
#Kernel - Volatility Equation
kernelVolat <- "Polynomial"
#parameters kernel - Volatility Equation
parmsVola <- matrix(c(2,1,
3,5,
4,7),ncol=2,nrow=3,byrow=T)
#Do the cross-validation
train<-train
valid<-valid
Cm<-Cmean
epsilonM<-epsilonMean
kernel<-kernelMean
parmMat<-parmsMean
Cg<-Cvola
epsilonG<-epsilonVola
kernelGarch<-kernelVolat
parmMatGarch<-parmsVola
ptm <- proc.time()
teste<-GarchSVR(train,valid,Cmean,epsilonMean,kernelMean,parmsMean,
Cvola,epsilonVola,kernelVolat,parmsVola)
library(mlRFinance)
#MlRFinance
rm(list=ls())
library(mlRFinance)
library(quantmod)
#Cria um novo ambiente para armazenar os dados
stockData <- new.env()
#Especifica as datas de interesse
startDate = as.Date("2011-01-01")
endDate = as.Date("2011-12-31")
#Obtêm os dados do ativo PETR4 e PETR3
getSymbols("^BVSP", src="yahoo",from=startDate,to=endDate)
#Calcula o log-retorno
retorno<-na.omit(diff(log(Cl(BVSP))))
#Training set
train <- as.numeric(retorno[1:180])
#Validation set
valid <- as.numeric(retorno[181:216])
#Cost parameter - Mean Equation
Cmean<-seq(0.01,0.05,length.out = 5)
#Epsilon parameter - Mean Equation
epsilonMean <-seq(0.04,0.1,length.out=7)
#Kernel mean equation
kernelMean <- "Gaussian"
#parameters kernel - Mean Equation
parmsMean <-matrix(c(1.0,
1.5,
2.0),ncol=1,nrow=3,byrow=T)
#Cost parameter - Volatility Equation
Cvola <-seq(0.5,0.7,length.out = 4)
#Epsilon parameter - Volatility Equation
epsilonVola <-seq(0.01,0.1,length.out=4)
#Kernel - Volatility Equation
kernelVolat <- "Polynomial"
#parameters kernel - Volatility Equation
parmsVola <- matrix(c(2,1,
3,5,
4,7),ncol=2,nrow=3,byrow=T)
#Do the cross-validation
train<-train
valid<-valid
Cm<-Cmean
epsilonM<-epsilonMean
kernel<-kernelMean
parmMat<-parmsMean
Cg<-Cvola
epsilonG<-epsilonVola
kernelGarch<-kernelVolat
parmMatGarch<-parmsVola
ptm <- proc.time()
teste<-GarchSVR(train,valid,Cmean,epsilonMean,kernelMean,parmsMean,
Cvola,epsilonVola,kernelVolat,parmsVola)
library(mlRFinance)
#MlRFinance
rm(list=ls())
library(mlRFinance)
library(quantmod)
#Cria um novo ambiente para armazenar os dados
stockData <- new.env()
#Especifica as datas de interesse
startDate = as.Date("2011-01-01")
endDate = as.Date("2011-12-31")
#Obtêm os dados do ativo PETR4 e PETR3
getSymbols("^BVSP", src="yahoo",from=startDate,to=endDate)
#Calcula o log-retorno
retorno<-na.omit(diff(log(Cl(BVSP))))
#Training set
train <- as.numeric(retorno[1:180])
#Validation set
valid <- as.numeric(retorno[181:216])
#Cost parameter - Mean Equation
Cmean<-seq(0.01,0.05,length.out = 5)
#Epsilon parameter - Mean Equation
epsilonMean <-seq(0.04,0.1,length.out=7)
#Kernel mean equation
kernelMean <- "Gaussian"
#parameters kernel - Mean Equation
parmsMean <-matrix(c(1.0,
1.5,
2.0),ncol=1,nrow=3,byrow=T)
#Cost parameter - Volatility Equation
Cvola <-seq(0.5,0.7,length.out = 4)
#Epsilon parameter - Volatility Equation
epsilonVola <-seq(0.01,0.1,length.out=4)
#Kernel - Volatility Equation
kernelVolat <- "Polynomial"
#parameters kernel - Volatility Equation
parmsVola <- matrix(c(2,1,
3,5,
4,7),ncol=2,nrow=3,byrow=T)
#Do the cross-validation
train<-train
valid<-valid
Cm<-Cmean
epsilonM<-epsilonMean
kernel<-kernelMean
parmMat<-parmsMean
Cg<-Cvola
epsilonG<-epsilonVola
kernelGarch<-kernelVolat
parmMatGarch<-parmsVola
ptm <- proc.time()
teste<-GarchSVR(train,valid,Cmean,epsilonMean,kernelMean,parmsMean,
Cvola,epsilonVola,kernelVolat,parmsVola)
library(mlRFinance)
library(mlRFinance)
library(mlRFinance)
