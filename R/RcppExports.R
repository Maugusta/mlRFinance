# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

ErrorMeasures <- function(y, yPred) {
    .Call('mlRFinance_ErrorMeasures', PACKAGE = 'mlRFinance', y, yPred)
}

#' @name Garch C-SVR L1
#' @title Garch C-SVR L1 - Garch Support Vector Regression with C cost and L1 regularization.
#' @description Training and Forecasting volatility
#'
#' @param train Vector of returns (training set). Dimension equal Nx1.
#' @param valid Vector of returns (validation set). Dimension equal Mx1.
#' @param C Cost parameter. Should be C>0.
#' @param epsilon Insentitive band. Should be epsilon>0.
#' @param kernel Name of the kernel that will be used for the mean equation.
#' @param parms Parameters associated with chosen kenel for the mean equation.
#' @param kernel Name of the kernel that will be used for the mean equation.
#' @param parms Parameters associated with chosen kenel for the mean equation.
#' @return List Support Vectors Mean, Forecast mean, EAMmean,
#' Support Vectors Volatility, Forecast volatility, EAMvolat, .
#' If the results for the Support Vectors are NaN it means that
#' there is no Support Vector and the Quadratic Programming Problem
#' is unfeasible.
#' @examples
#'
#' A<-matrix(c(1,2,5,6,
#' 2,4,1,2),nrow=4,ncol=2)
#' d<-c(-1,-1,+1,-1)
#' svm1<- CSVML1(d, A, 1, 0.1, "Gaussian", c(0.5))
#'
#' @seealso See \code{\link{.CallOctave}}, \code{\link{o_source}}, \code{\link{o_help}}
NULL

GARCHCSVRL1 <- function(train, valid, Cmean, epsilonMean, Cvola, epsilonVola, kernelMean, parmsMean, kernelVolat, parmsVola) {
    .Call('mlRFinance_GARCHCSVRL1', PACKAGE = 'mlRFinance', train, valid, Cmean, epsilonMean, Cvola, epsilonVola, kernelMean, parmsMean, kernelVolat, parmsVola)
}

KernelMatrixComputation <- function(datMat, stringValue, parms) {
    .Call('mlRFinance_KernelMatrixComputation', PACKAGE = 'mlRFinance', datMat, stringValue, parms)
}

KernelMatrixComputationPred <- function(datMat, predMat, stringValue, parms) {
    .Call('mlRFinance_KernelMatrixComputationPred', PACKAGE = 'mlRFinance', datMat, predMat, stringValue, parms)
}

quadprogEquality <- function(G, c, A, b) {
    .Call('mlRFinance_quadprogEquality', PACKAGE = 'mlRFinance', G, c, A, b)
}

quadprogInequality <- function(sol, G, c, A, b) {
    .Call('mlRFinance_quadprogInequality', PACKAGE = 'mlRFinance', sol, G, c, A, b)
}

parallelMatrixSqrt <- function(x) {
    .Call('mlRFinance_parallelMatrixSqrt', PACKAGE = 'mlRFinance', x)
}

rcpp_parallel_js_distance <- function(mat) {
    .Call('mlRFinance_rcpp_parallel_js_distance', PACKAGE = 'mlRFinance', mat)
}

rcppeigen_quadratic_solve <- function(G, g0, CE, ce0, CI, ci0) {
    .Call('mlRFinance_rcppeigen_quadratic_solve', PACKAGE = 'mlRFinance', G, g0, CE, ce0, CI, ci0)
}

#' @name WOC-SCM
#' @title WOC-SCM - Support Vector Clustering
#' @description Optimize the Lagrange multiplier for the WOC-SCM:
#'
#' Min (1/2)u^{t}Qu+g^{t}u
#' s.t.
#' 0<=u<=wi*C
#' sum ui=1
#' where g=diag(K) and Q=-2K
#' C is the Cost parameter, wi weights for each observation
#'
#' @param X Numeric matrix with the explanatory variables. Dimension equal NxP
#' @param C Cost parameter. Should be C>=0.
#' @param k Total number of clusters.
#' @param sigma Similarity parameter.
#' @param inter Total number of interations.
#' @param parms Parameters associated with chosen kenel.
#' @return List Support Vectors, Kernel used, parameters and similarity matrix.
#' If the results for the Support Vectors are NaN it means that
#' there is no Support Vector and the Quadratic Programming Problem
#' is unfeasible.
#' @examples
#'
#' A<-matrix(c(1,2,5,6,
#'             5,5,2,1,
#'             8,1,1,7),nrow=4,ncol=3)
#' svc<-WOCSCM(A, 1, 2, 1, 100, "Gaussian", c(0.5))
#' svc
#' @seealso See \code{\link{.CallOctave}}, \code{\link{o_source}}, \code{\link{o_help}}
NULL

WOCSCM <- function(X, C, k, sigma, inter, kernel, parms) {
    .Call('mlRFinance_WOCSCM', PACKAGE = 'mlRFinance', X, C, k, sigma, inter, kernel, parms)
}

#' @name CSVML1
#' @title C-SVM L1 - Support Vector Regression with C cost and L1 regularization.
#' @description Optimize the Lagrange multiplier for the C-SVM L1:
#'
#' Min (1/2)u^{t}Qu-1^{t}u
#' s.t.
#' 0<=u<=C1
#'
#' where d is the vector of dependent variable,
#' and Q=K.*(d*t(d))=DKD. C is the Cost parameter.
#'
#' @param y Vector with dependent variables should be -1 or +1. Dimension equal Nx1.
#' @param X Numeric matrix with the explanatory variables. Dimension equal NxP
#' @param C Cost parameter. Should be C>0.
#' @param kernel Name of the kernel that will be used.
#' @param parms Parameters associated with chosen kenel.
#' @return List Support Vectors, Kernel used and parameters.
#' If the results for the Support Vectors are NaN it means that
#' there is no Support Vector and the Quadratic Programming Problem
#' is unfeasible.
#' @examples
#'
#' A<-matrix(c(1,2,5,6,
#' 2,4,1,2),nrow=4,ncol=2)
#' d<-c(-1,-1,+1,-1)
#' svm1<- CSVML1(d, A, 1, "Gaussian", c(0.5))
#'
#' @seealso See \code{\link{.CallOctave}}, \code{\link{o_source}}, \code{\link{o_help}}
NULL

#' @name CSVML2
#' @title C-SVM L2 - Support Vector Regression with C cost and L2 regularization.
#' @description Optimize the Lagrange multiplier for the C-SVM L2:
#'
#' Min (1/2)u^{t}Qu-1^{t}u
#' s.t.
#' u>=0
#'
#' where d is the vector of dependent variable,
#' and Q=(K+I/C).*(t(d)*d). C is the Cost parameter.
#'
#' @param y Vector with dependent variables should be -1 or +1. Dimension equal Nx1.
#' @param X Numeric matrix with the explanatory variables. Dimension equal NxP
#' @param C Cost parameter. Should be C>0.
#' @param kernel Name of the kernel that will be used.
#' @param parms Parameters associated with chosen kenel.
#' @return List Support Vectors, Kernel used and parameters.
#' If the results for the Support Vectors are NaN it means that
#' there is no Support Vector and the Quadratic Programming Problem
#' is unfeasible.
#' @examples
#'
#' A<-matrix(c(1,2,5,6,
#' 2,4,1,2),nrow=4,ncol=2)
#' d<-c(-1,-1,+1,-1)
#' svm1<- CSVML2(d, A, 1, "Gaussian", c(0.5))
#'
#' @seealso See \code{\link{.CallOctave}}, \code{\link{o_source}}, \code{\link{o_help}}
NULL

#' @name nuSVM
#' @title nu-SVM - Support Vector Regression with nu parameter.
#' @description The m-support vector classification (Scholkopf, Smola,
#' Williamson, & Bartlett, 2000) uses a new parameter nu which controls
#' the number of support vectors and training errors. The
#' parameter nu in (0, 1] is an upper bound on the fraction of training
#' errors and a lower bound of the fraction of support vectors.
#'
#' Min (1/2)u^{t}Qu-1^{t}u
#' s.t.
#' d^{t}*u=0
#' nu <=1^t*u
#' 0<=u<=1/l
#'
#' where d is the vector of dependent variable,
#' and Q=K.*(t(d)*d). nu is the parameter.
#'
#' @param y Vector with dependent variables should be -1 or +1. Dimension equal Nx1.
#' @param X Numeric matrix with the explanatory variables. Dimension equal NxP
#' @param C Cost parameter. Should be C>0.
#' @param kernel Name of the kernel that will be used.
#' @param parms Parameters associated with chosen kenel.
#' @return List Support Vectors, Kernel used and parameters.
#' If the results for the Support Vectors are NaN it means that
#' there is no Support Vector and the Quadratic Programming Problem
#' is unfeasible.
#' @examples
#'
#' A<-matrix(c(1,2,5,6,
#' 2,4,1,2),nrow=4,ncol=2)
#' d<-c(-1,-1,+1,-1)
#' svm1<- nuSVM(d, A, 0.2, "Gaussian", c(0.5))
#'
#' @seealso See \code{\link{.CallOctave}}, \code{\link{o_source}}, \code{\link{o_help}}
NULL

CSVML1 <- function(y, X, C, kernel, parms) {
    .Call('mlRFinance_CSVML1', PACKAGE = 'mlRFinance', y, X, C, kernel, parms)
}

CSVML2 <- function(y, X, C, kernel, parms) {
    .Call('mlRFinance_CSVML2', PACKAGE = 'mlRFinance', y, X, C, kernel, parms)
}

nuSVM <- function(y, X, nu, kernel, parms) {
    .Call('mlRFinance_nuSVM', PACKAGE = 'mlRFinance', y, X, nu, kernel, parms)
}

solveTest <- function(Dmat, dvec, Amat, bvec, CE, ce) {
    .Call('mlRFinance_solveTest', PACKAGE = 'mlRFinance', Dmat, dvec, Amat, bvec, CE, ce)
}

solveTest2 <- function(Dmat, dvec, Amat, bvec) {
    .Call('mlRFinance_solveTest2', PACKAGE = 'mlRFinance', Dmat, dvec, Amat, bvec)
}

#' @name CSVRL1
#' @title C-SVR L1 - Support Vector Regression with C cost and L1 regularization.
#' @description Optimize the Lagrange multiplier for the C-SVR L1:
#'
#' Min (1/2)u^{t}Qu+g^{t}u
#' s.t.
#' 0<=u<=C1
#'
#' where u=(lambda*,lambda), g=(e-y,e+y)
#' and Q=|K -K|.
#'       |-K K|
#' C is the Cost parameter and e (epsilon) is the insentitive band
#'
#' @param y Vector with dependent variables. Dimension equal Nx1.
#' @param X Numeric matrix with the explanatory variables. Dimension equal NxP
#' @param C Cost parameter. Should be C>0.
#' @param epsilon Insentitive band. Should be epsilon>0.
#' @param kernel Name of the kernel that will be used.
#' @param parms Parameters associated with chosen kenel.
#' @return List Support Vectors, Kernel used and parameters.
#' If the results for the Support Vectors are NaN it means that
#' there is no Support Vector and the Quadratic Programming Problem
#' is unfeasible.
#' @examples
#'
#' A<-matrix(c(1,2,5,6,
#' 2,4,1,2),nrow=4,ncol=2)
#' d<-c(-1,-1,+1,-1)
#' svm1<- CSVML1(d, A, 1, 0.1, "Gaussian", c(0.5))
#'
#' @seealso See \code{\link{.CallOctave}}, \code{\link{o_source}}, \code{\link{o_help}}
NULL

#' @name Predicted CSVRL1
#' @title C-SVR L1 - Support Vector Regression with C cost and L1 regularization.
#' @description Prediction for the C-SVR L1:
#'
#' f(x)=Sum_{i=1}^{N}(lambda*-lambda)K(x_{i},x)
#' @param CSVRL1 List of Results of the CSVRL1
#' @param X Numeric matrix with the explanatory variables. Dimension equal NxP
#' @param Xprev Numeric matrix with the explanatory variables (predicted). Dimension equal MxP
#' @param kernel Name of the kernel that will be used.
#' @param parms Parameters associated with chosen kenel.
#' @return Eigen::VectorXd with the predicted values for Xpred
#' @examples
#'
#' A<-matrix(c(1,2,5,6,
#' 2,4,1,2),nrow=4,ncol=2)
#' d<-c(-1,-1,+1,-1)
#' svm1<- CSVML1(d, A, 1, 0.1, "Gaussian", c(0.5))
#'
#' @seealso See \code{\link{.CallOctave}}, \code{\link{o_source}}, \code{\link{o_help}}
NULL

#' @param y Vector with dependent variables. Dimension equal Nx1.
#' @param X Numeric matrix with the explanatory variables. Dimension equal NxP
#' @param epsilon Insentitive band. Should be epsilon>0.
#' @param kernel Name of the kernel that will be used.
#' @param parms Parameters associated with chosen kenel.
NULL

CSVRL1 <- function(y, X, C, epsilon, kernel, parms) {
    .Call('mlRFinance_CSVRL1', PACKAGE = 'mlRFinance', y, X, C, epsilon, kernel, parms)
}

PredictedCSVRL1 <- function(CSVRL1, X, Xprev, kernel, parms) {
    .Call('mlRFinance_PredictedCSVRL1', PACKAGE = 'mlRFinance', CSVRL1, X, Xprev, kernel, parms)
}

minimumCSVRL1 <- function(y, X, epsilon, kernel, parms) {
    .Call('mlRFinance_minimumCSVRL1', PACKAGE = 'mlRFinance', y, X, epsilon, kernel, parms)
}

nearPDefinite <- function(mat, maxit = 1e+6L, eigtol = 1e-06, conv_tol = 1e-07, posd_tol = 1e-08) {
    .Call('mlRFinance_nearPDefinite', PACKAGE = 'mlRFinance', mat, maxit, eigtol, conv_tol, posd_tol)
}

