{
    "collab_server" : "",
    "contents" : "#include <RcppArmadillo.h>\n#include <RcppEigen.h>\n#include \"eiquadprog.h\"\n#include \"KernelMatrix.h\"\n#include \"Utils.h\"\n// [[Rcpp::depends(RcppArmadillo)]]\n// [[Rcpp::depends(RcppEigen)]]\n#include <cmath>\nusing namespace Rcpp;\n\n/***********************************************************************************************/\n/*********************************    HEADER FUNCTIONS  ****************************************/\n/***********************************************************************************************/\n\n//Define the KernelMatrix function\nEigen::MatrixXd KernelMatrixComputation(Eigen::MatrixXd datMat,\n                                        std::string stringValue,\n                                        arma::vec parms);\n//Define the Solver for Quadratic Programming\nEigen::VectorXd rcppeigen_quadratic_solve(Eigen::MatrixXd & G,\n                                          Eigen::VectorXd & g0,\n                                          const Eigen::MatrixXd & CE,\n                                          const Eigen::VectorXd & ce0,\n                                          const Eigen::MatrixXd & CI,\n                                          const Eigen::VectorXd & ci0);\n//Test if the matrix is Positive Definite\nbool IsPositiveDefinite(Eigen::MatrixXd mat);\n//nearest positive semidefinite matrix in terms of Frobenius norm\nvoid nearPositiveDefinite(Eigen::MatrixXd &mat,double noise);\n//Add some noise to the matrix diagonal\nvoid addNoise(Eigen::MatrixXd &mat,double noise);\n//Print Object at Console\nvoid PrintObject(Eigen::MatrixXd mat);\nvoid PrintObject(Eigen::VectorXd vec);\n\n\n/***********************************************************************************************/\n/*********************************     SVC FUNCTIONS    ****************************************/\n/***********************************************************************************************/\n\n/**\n *\nEigen::MatrixXf m(2,4);\nEigen::VectorXf v(2);\n\nm << 1, 23, 6, 9,\n     3, 11, 7, 2;\n\nv << 2,\n     3;\n*/\n\n//' @name WOC-SCM\n//' @title WOC-SCM - Support Vector Clustering\n//' @description Optimize the Lagrange multiplier for the WOC-SCM:\n//'\n//' Min (1/2)u^{t}Qu+g^{t}u\n//' s.t.\n//' 0<=u<=wi*C\n//' sum ui=1\n//' where g=diag(K) and Q=-2K\n//' C is the Cost parameter, wi weights for each observation\n//'\n//' @param X Numeric matrix with the explanatory variables. Dimension equal NxP\n//' @param C Cost parameter. Should be C>0.\n//' @param k Total number of clusters.\n//' @param sigma Similarity parameter.\n//' @param inter Total number of interations.\n//' @param parms Parameters associated with chosen kenel.\n//' @return List Support Vectors, Kernel used, parameters and similarity matrix.\n//' If the results for the Support Vectors are NaN it means that\n//' there is no Support Vector and the Quadratic Programming Problem\n//' is unfeasible.\n//' @examples\n//'\n//' A<-matrix(c(1,2,5,6,\n//' 2,4,1,2),nrow=4,ncol=2)\n//' d<-c(-1,-1,+1,-1)\n//' svm1<- CSVML1(d, A, 1, 0.1, \"Gaussian\", c(0.5))\n//'\n//' @seealso See \\code{\\link{.CallOctave}}, \\code{\\link{o_source}}, \\code{\\link{o_help}}\n// @cite Soft clustering using weighted one-class support vector machines\n// @bibliography ~/vignettes/bibliography.bib\n// [[Rcpp::export]]\nRcpp::List WOCSCM(Eigen::MatrixXd X, double C, int k,double sigma,int inter, std::string kernel, arma::vec parms){\n  //Initialize the vector weights\n  Eigen::VectorXd vecW(X.rows());\n  vecW.fill(1.0/(double)X.rows());\n  //Cluster weights\n  Eigen::VectorXd gammaWeight(k);\n  gammaWeight.fill(1.0/(double)k);\n  //Support Vectors\n  Eigen::VectorXd SV(X.cols());\n  //Z matrix\n  Eigen::MatrixXd zMat(X.rows(),k);\n  Eigen::MatrixXd simVec(X.rows(),k);\n  //Initialize logLikelihood\n  Eigen::VectorXd llVec(inter);\n  //Create the Kernel Matrix\n  Eigen::MatrixXd K = KernelMatrixComputation(X,kernel,parms);\n  //Nearest positive semidefinite matrix in terms of Frobenius norm\n  nearPositiveDefinite(K,1e-10);\n  //Training the WOC-SCM\n  Eigen::VectorXd g(X.rows());\n  g = K.diagonal();\n  //Quadratic programming matrix\n Eigen::MatrixXd Q = (-2.0)*K;\n  //RHS equality\n  Eigen::VectorXd ce0(X.rows());\n  ce0.fill(-1.0);\n  //LHS equality\n  Eigen::MatrixXd CE = Eigen::MatrixXd::Identity(X.rows(),X.rows());\n  //RHS: Inequality 1\n  Eigen::VectorXd ci1 = Eigen::VectorXd::Zero(X.rows());\n  //LHS: Inequality 1\n  Eigen::MatrixXd CI1 = Eigen::MatrixXd::Identity(X.rows(),X.rows());\n  for(int it=0;it<inter;it++){\n    //Initialize the loop\n    for(int c=0;c<k;c++){\n      //RHS: Inequality 2\n      Eigen::VectorXd ci2(X.rows());\n      ci2.fill(C);\n      //Weighted Cost parameter\n      ci2=ci2.array()*vecW.array();\n      //Append RHS\n      Eigen::VectorXd ci0(2.0*X.rows());\n      ci0 << ci1, ci2;\n      //Append LHS\n      Eigen::MatrixXd CI(CI1.rows()+CI1.rows(), CI1.cols());\n      //Diagonal matrix\n      Eigen::VectorXd me(X.rows());\n      me.fill(-1.0);\n      Eigen::MatrixXd mI = me.asDiagonal();\n      //Vertical concatenation\n      CI << CI1,\n            mI;\n      //Get the solution Support Vectors\n      SV = rcppeigen_quadratic_solve(Q,g, CE.transpose(),ce0, CI.transpose(), ci0);\n      //Get the center of the Hypersphere\n      Eigen::RowVectorXd centerA = SV.transpose()*X;\n      //For each line\n      Eigen::VectorXd zVec = ((X.rowwise() - centerA).rowwise().squaredNorm());\n      zVec=zVec/sigma;\n      //For each cluster\n//      zVec = zVec.exp()*gammaWeight;\n      //Store the similarity\n//      simVec.col(c) = zVec;\n      //Store the column\n//      zMat.col(c) = zVec;\n    }\n    //Normalize zMat\n    //    zMat.array().rowwise()/=zMat.array().colwise().sum().eval();\n    //M-Step\n    for(int c=0;c<k;c++){\n      //Get the new weights\n      //      vecW = zMat.col(c);\n      //Update gammaWeight\n      //      gammaWeight = (1.0/X.rows())*zMat.rowwise().sum();\n      //RHS: Inequality 2\n      //      Eigen::VectorXd ci2(X.rows());\n      //      ci2.fill(C);\n      //Weighted Cost parameter\n      //      ci2=ci2*vecW;\n      //Append RHS\n      //      Eigen::VectorXd ci0(2.0*X.rows());\n      //      ci0 << ci1, ci2;\n      //Append LHS\n      //      Eigen::MatrixXd CI(CI1.rows()+CI1.rows(), CI1.cols());\n      //Diagonal matrix\n      //      Eigen::VectorXd me(X.rows());\n      //      me.fill(-1.0);\n      //      Eigen::MatrixXd mI = me.asDiagonal();\n      //Vertical concatenation\n      //      CI << CI1,\n      //            mI;\n      //Get the solution Support Vectors\n      //      SV = rcppeigen_quadratic_solve(Q,g, CE.transpose(),ce0, CI.transpose(), ci0);\n    }\n    //Compute the log-likelihood\n    //    double ll=simVec.colwise().sum().log().sum();\n    //    llVec(it)=ll;\n  }\n\n  //Return the results\n  return Rcpp::List::create(Rcpp::Named(\"LogLikelihood\") = SV,\n                            Rcpp::Named(\"Zmat\") = zMat,\n                            Rcpp::Named(\"Kernel\") = kernel,\n                            Rcpp::Named(\"Parameters\") = parms);\n}\n\n\n",
    "created" : 1476924204380.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "2092814988",
    "id" : "F962E91A",
    "lastKnownWriteTime" : 1476926359,
    "last_content_update" : 1476926359727,
    "path" : "C:/Users/ASUS/Dropbox/mlRFinance/src/SVC.cpp",
    "project_path" : "src/SVC.cpp",
    "properties" : {
    },
    "relative_order" : 2,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "cpp"
}