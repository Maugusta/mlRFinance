{
    "collab_server" : "",
    "contents" : "#include <RcppArmadillo.h>\n#include <RcppEigen.h>\n#include \"KernelComputation.h\"\n// [[Rcpp::depends(RcppArmadillo)]]\n// [[Rcpp::depends(RcppEigen)]]\n#include <cmath>\n#include <functional>\n\nusing namespace Rcpp;\n\n//TODO: Reescrever os kernels usando Eigen ao inv√©s de arma e remover esse casting da linha 32\n//Typecasting between Eigen::MatrixXd datMat and arma::mat\narma::mat convertEigenToArma(Eigen::MatrixXd datMat){\n  arma::mat res(datMat.rows(), datMat.cols());\n  for(int i=0;i<datMat.rows();i++){\n    for(int j=0;j<datMat.cols();j++){\n      res(i,j)=datMat(i,j);\n    }\n  }\n  return(res);\n}\n\n//Typecasting between Eigen::MatrixXd datMat and arma::mat\narma::vec convertEigenToArma(Eigen::RowVectorXd datMat){\n  arma::vec res(datMat.size());\n  for(int i=0;i<datMat.size();i++){\n      res(i)=datMat(i);\n  }\n  return(res);\n}\n\n// Create the Kernel matrix\n// @param datMat  Matrix with the data\n// @param function Kernel Function\n// @param parms vector of parameters fot the kernel\n// @return Kernel Matrix\nEigen::VectorXd KernelMatrix(Eigen::MatrixXd datMat, Eigen::RowVectorXd predMat,const std::function<double (arma::vec, arma::vec, arma::vec)> kernel, arma::vec parms){\n  //Get the number of rows\n  int rows=datMat.rows();\n  //Typecasting\n  arma::mat datMat2 = convertEigenToArma(datMat);\n  arma::vec datPred2 = convertEigenToArma(predMat);\n  //Initialize the matriz\n  Eigen::VectorXd matKernel = Eigen::VectorXd::Zero(rows);\n  for(unsigned int c1=0;c1<rows;c1++){\n      //First column with variables\n      arma::vec vec1 = datMat2.row(c1).t();\n      //Calculate the kernel value\n      double val= kernel(vec1,datPred2,parms);\n      //Store the kernel value\n      matKernel(c1)=val;\n  }\n\n  return(matKernel);\n}\n\n// Create the Kernel matrix\n// @param datMat  Matrix with the data\n// @param function Kernel Function\n// @param parms vector of parameters fot the kernel\n// @return Kernel Matrix\nEigen::MatrixXd KernelMatrix(Eigen::MatrixXd datMat,const std::function<double (arma::vec, arma::vec, arma::vec)> kernel, arma::vec parms){\n  //Get the number of rows\n  int rows=datMat.rows();\n  //Typecasting\n  arma::mat datMat2 = convertEigenToArma(datMat);\n  //Initialize the matriz\n  Eigen::MatrixXd matKernel = Eigen::MatrixXd::Zero(rows,rows);\n  for(unsigned int c1=0;c1<rows;c1++){\n    for(unsigned int c2=c1;c2<rows;c2++){\n      //First column with variables\n      arma::vec vec1 = datMat2.row(c1).t();\n      //Second column with variables\n      arma::vec vec2 = datMat2.row(c2).t();\n      //Calculate the kernel value\n      double val= kernel(vec1,vec2,parms);\n      //Store the kernel value\n      matKernel(c1,c2)=matKernel(c2,c1)=val;\n    }\n  }\n\n  return(matKernel);\n}\n\n//Define the Kernel functions\ndouble CauchyKernel(arma::vec x,arma::vec y,arma::vec parms);\ndouble PolynomialKernel(arma::vec x,arma::vec y,arma::vec parms);\ndouble ChiSquareKernel(arma::vec x,arma::vec y,arma::vec parms);\ndouble ExponentialKernel(arma::vec x,arma::vec y,arma::vec parms);\ndouble GaussianKernel(arma::vec x,arma::vec y,arma::vec parms);\ndouble GeneralizedTStudentKernel(arma::vec x,arma::vec y,arma::vec parms);\ndouble HyperbolicTangentKernel(arma::vec x,arma::vec y,arma::vec parms);\ndouble InverseMultiquadraticKernel(arma::vec x,arma::vec y,arma::vec parms);\ndouble LaplacianoKernel(arma::vec x,arma::vec y,arma::vec parms);\ndouble LinearKernel(arma::vec x,arma::vec y,arma::vec parms);\ndouble LogLinearKernel(arma::vec x,arma::vec y,arma::vec parms);\ndouble MultiquadraticKernel(arma::vec x,arma::vec y,arma::vec parms);\ndouble PowerKernel(arma::vec x,arma::vec y,arma::vec parms);\ndouble RationalQuadraticKernel(arma::vec x,arma::vec y,arma::vec parms);\ndouble WaveletKernel(arma::vec x,arma::vec y,arma::vec parms);\ndouble HistogramIntersectionKernel(arma::vec x,arma::vec y,arma::vec parms);\ndouble WaveletKernel(arma::vec x,arma::vec y,arma::vec parms);\ndouble MexicanHatKernel(arma::vec x,arma::vec y,arma::vec parms);\ndouble MorletKernel(arma::vec x,arma::vec y,arma::vec parms);\ndouble GeneralizedHistogramIntersectionKernel(arma::vec x,arma::vec y,arma::vec parms);\ndouble CircularKernel(arma::vec x,arma::vec y,arma::vec parms);\ndouble SphericalKernel(arma::vec x,arma::vec y,arma::vec parms);\ndouble LogKernel(arma::vec x,arma::vec y,arma::vec parms);\ndouble WaveKernel(arma::vec x,arma::vec y,arma::vec parms);\ndouble HellingerKernel(arma::vec x,arma::vec y,arma::vec parms);\ndouble DirichletKernel(arma::vec x,arma::vec y,arma::vec parms);\ndouble PearsonKernel(arma::vec x,arma::vec y,arma::vec parms);\ndouble SigmoidKernel(arma::vec x,arma::vec y,arma::vec parms);\ndouble SquaredSincKernel(arma::vec x,arma::vec y,arma::vec parms);\ndouble SymmetricTriangleKernel(arma::vec x,arma::vec y,arma::vec parms);\ndouble ThinSplinePlateKernel(arma::vec x,arma::vec y,arma::vec parms);\ndouble ANOVAKernel(arma::vec x,arma::vec y,arma::vec parms);\ndouble SplineKernel(arma::vec x,arma::vec y,arma::vec parms);\ndouble BesselKernel(arma::vec x,arma::vec y,arma::vec parms);\ndouble ArccosKernel(arma::vec x,arma::vec y,arma::vec parms);\n\n//TODO: Testar se o Kernel construido eh semi-positivo definido e caso nao seja, trocar os autovalores negativos por zero.\n//TODO: http://scicomp.stackexchange.com/questions/10450/how-to-implement-the-spectral-decomposition-of-a-symmetric-dense-matrix-via-eige\n//TOOD: https://eigen.tuxfamily.org/dox/classEigen_1_1EigenSolver.html\n// [[Rcpp::export]]\nEigen::MatrixXd KernelMatrixComputation(Eigen::MatrixXd datMat,std::string stringValue, arma::vec parms){\n  //Get the number of columns\n  int rows=datMat.rows();\n  //Initialize the matrix\n  Eigen::MatrixXd Kernel = Eigen::MatrixXd::Zero(rows,rows);\n\n  if(stringValue==\"Cauchy\"){\n    Kernel = KernelMatrix(datMat, CauchyKernel ,parms);\n  }\n  else if(stringValue==\"Chi-Square\"){\n    Kernel = KernelMatrix(datMat, ChiSquareKernel ,parms);\n  }\n  else if(stringValue==\"Exponential\"){\n    Kernel = KernelMatrix(datMat, ExponentialKernel ,parms);\n  }\n  else if(stringValue==\"Gaussian\"){\n    Kernel = KernelMatrix(datMat, GaussianKernel ,parms);\n  }\n  else if(stringValue==\"Generalized T-Student\"){\n    Kernel = KernelMatrix(datMat, GeneralizedTStudentKernel ,parms);\n  }\n  else if(stringValue==\"Hyperbolic Tangent\"){\n    Kernel = KernelMatrix(datMat, HyperbolicTangentKernel ,parms);\n  }\n  else if(stringValue==\"Inverse Multiquadratic\"){\n    Kernel = KernelMatrix(datMat, InverseMultiquadraticKernel ,parms);\n  }\n  else if(stringValue==\"Laplacian\"){\n    Kernel = KernelMatrix(datMat, LaplacianoKernel ,parms);\n  }\n  else if(stringValue==\"Linear\"){\n    Kernel = KernelMatrix(datMat, LinearKernel ,parms);\n  }\n  else if(stringValue==\"Log-Linear\"){\n    Kernel = KernelMatrix(datMat, LogLinearKernel ,parms);\n  }\n  else if(stringValue==\"Polynomial\"){\n    Kernel = KernelMatrix(datMat, PolynomialKernel ,parms);\n  }\n  else if(stringValue==\"Multiquadratic\"){\n    Kernel = KernelMatrix(datMat, MultiquadraticKernel ,parms);\n  }\n  else if(stringValue==\"Power\"){\n    Kernel = KernelMatrix(datMat, PowerKernel ,parms);\n  }\n  else if(stringValue==\"Rational Quadratic\"){\n    Kernel = KernelMatrix(datMat, RationalQuadraticKernel ,parms);\n  }\n  else if(stringValue==\"Wavelet\"){\n    Kernel = KernelMatrix(datMat, WaveletKernel ,parms);\n  }\n  else if(stringValue==\"Histogram Intersection\"){\n    Kernel = KernelMatrix(datMat, HistogramIntersectionKernel ,parms);\n  }\n  else if(stringValue==\"Mexican-Hat\"){\n    Kernel = KernelMatrix(datMat, MexicanHatKernel ,parms);\n  }\n  else if(stringValue==\"Morlet\"){\n    Kernel = KernelMatrix(datMat, MorletKernel ,parms);\n  }\n  else if(stringValue==\"Generalized Histogram Intersection\"){\n    Kernel = KernelMatrix(datMat, GeneralizedHistogramIntersectionKernel ,parms);\n  }\n  else if(stringValue==\"Circular\"){\n    Kernel = KernelMatrix(datMat, CircularKernel ,parms);\n  }\n  else if(stringValue==\"Spherical\"){\n    Kernel = KernelMatrix(datMat, SphericalKernel ,parms);\n  }\n  else if(stringValue==\"Log-Kernel\"){\n    Kernel = KernelMatrix(datMat, LogKernel ,parms);\n  }\n  else if(stringValue==\"Wave\"){\n    Kernel = KernelMatrix(datMat, WaveKernel ,parms);\n  }\n  else if(stringValue==\"Hellinger\"){\n    Kernel = KernelMatrix(datMat, HellingerKernel ,parms);\n  }\n  else if(stringValue==\"Dirichlet\"){\n    Kernel = KernelMatrix(datMat, DirichletKernel ,parms);\n  }\n  else if(stringValue==\"Pearson\"){\n    Kernel = KernelMatrix(datMat, PearsonKernel ,parms);\n  }\n  else if(stringValue==\"Sigmoid\"){\n    Kernel = KernelMatrix(datMat, SigmoidKernel ,parms);\n  }\n  else if(stringValue==\"Symmetric Triangle\"){\n    Kernel = KernelMatrix(datMat, SymmetricTriangleKernel ,parms);\n  }\n  else if(stringValue==\"Thin Spline Plate\"){\n    Kernel = KernelMatrix(datMat, ThinSplinePlateKernel ,parms);\n  }\n  else if(stringValue==\"ANOVA\"){\n    Kernel = KernelMatrix(datMat, ANOVAKernel ,parms);\n  }\n  else if(stringValue==\"Spline\"){\n    Kernel = KernelMatrix(datMat, SplineKernel ,parms);\n  }\n  else if(stringValue==\"Bessel\"){\n    Kernel = KernelMatrix(datMat, BesselKernel ,parms);\n  }\n  else if(stringValue==\"Arccos\"){\n    Kernel = KernelMatrix(datMat, ArccosKernel ,parms);\n  }\n  return(Kernel);\n}\n\n\n// [[Rcpp::export]]\nEigen::MatrixXd KernelMatrixComputationPred(Eigen::MatrixXd datMat, Eigen::RowVectorXd predMat,std::string stringValue, arma::vec parms){\n  //Get the number of columns\n  int rows=datMat.rows();\n  //Initialize the matrix\n  Eigen::VectorXd Kernel = Eigen::VectorXd::Zero(rows);\n\n\n  if(stringValue==\"Cauchy\"){\n    Kernel = KernelMatrix(datMat, predMat, CauchyKernel ,parms);\n  }\n  else if(stringValue==\"Chi-Square\"){\n    Kernel = KernelMatrix(datMat, predMat, ChiSquareKernel ,parms);\n  }\n  else if(stringValue==\"Exponential\"){\n    Kernel = KernelMatrix(datMat, predMat, ExponentialKernel ,parms);\n  }\n  else if(stringValue==\"Gaussian\"){\n    Kernel = KernelMatrix(datMat, predMat, GaussianKernel ,parms);\n  }\n  else if(stringValue==\"Generalized T-Student\"){\n    Kernel = KernelMatrix(datMat, predMat, GeneralizedTStudentKernel ,parms);\n  }\n  else if(stringValue==\"Hyperbolic Tangent\"){\n    Kernel = KernelMatrix(datMat, predMat, HyperbolicTangentKernel ,parms);\n  }\n  else if(stringValue==\"Inverse Multiquadratic\"){\n    Kernel = KernelMatrix(datMat, predMat, InverseMultiquadraticKernel ,parms);\n  }\n  else if(stringValue==\"Laplacian\"){\n    Kernel = KernelMatrix(datMat, predMat, LaplacianoKernel ,parms);\n  }\n  else if(stringValue==\"Linear\"){\n    Kernel = KernelMatrix(datMat, predMat, LinearKernel ,parms);\n  }\n  else if(stringValue==\"Log-Linear\"){\n    Kernel = KernelMatrix(datMat, predMat, LogLinearKernel ,parms);\n  }\n  else if(stringValue==\"Polynomial\"){\n    Kernel = KernelMatrix(datMat, predMat, PolynomialKernel ,parms);\n  }\n  else if(stringValue==\"Multiquadratic\"){\n    Kernel = KernelMatrix(datMat, predMat, MultiquadraticKernel ,parms);\n  }\n  else if(stringValue==\"Power\"){\n    Kernel = KernelMatrix(datMat, predMat, PowerKernel ,parms);\n  }\n  else if(stringValue==\"Rational Quadratic\"){\n    Kernel = KernelMatrix(datMat, predMat, RationalQuadraticKernel ,parms);\n  }\n  else if(stringValue==\"Wavelet\"){\n    Kernel = KernelMatrix(datMat, predMat, WaveletKernel ,parms);\n  }\n  else if(stringValue==\"Histogram Intersection\"){\n    Kernel = KernelMatrix(datMat, predMat, HistogramIntersectionKernel ,parms);\n  }\n  else if(stringValue==\"Mexican-Hat\"){\n    Kernel = KernelMatrix(datMat, predMat, MexicanHatKernel ,parms);\n  }\n  else if(stringValue==\"Morlet\"){\n    Kernel = KernelMatrix(datMat, predMat, MorletKernel ,parms);\n  }\n  else if(stringValue==\"Generalized Histogram Intersection\"){\n    Kernel = KernelMatrix(datMat, predMat, GeneralizedHistogramIntersectionKernel ,parms);\n  }\n  else if(stringValue==\"Circular\"){\n    Kernel = KernelMatrix(datMat, predMat, CircularKernel ,parms);\n  }\n  else if(stringValue==\"Spherical\"){\n    Kernel = KernelMatrix(datMat, predMat, SphericalKernel ,parms);\n  }\n  else if(stringValue==\"Log-Kernel\"){\n    Kernel = KernelMatrix(datMat, predMat, LogKernel ,parms);\n  }\n  else if(stringValue==\"Wave\"){\n    Kernel = KernelMatrix(datMat, predMat, WaveKernel ,parms);\n  }\n  else if(stringValue==\"Hellinger\"){\n    Kernel = KernelMatrix(datMat, predMat, HellingerKernel ,parms);\n  }\n  else if(stringValue==\"Dirichlet\"){\n    Kernel = KernelMatrix(datMat, predMat, DirichletKernel ,parms);\n  }\n  else if(stringValue==\"Pearson\"){\n    Kernel = KernelMatrix(datMat, predMat, PearsonKernel ,parms);\n  }\n  else if(stringValue==\"Sigmoid\"){\n    Kernel = KernelMatrix(datMat, predMat, SigmoidKernel ,parms);\n  }\n  else if(stringValue==\"Symmetric Triangle\"){\n    Kernel = KernelMatrix(datMat, predMat, SymmetricTriangleKernel ,parms);\n  }\n  else if(stringValue==\"Thin Spline Plate\"){\n    Kernel = KernelMatrix(datMat, predMat, ThinSplinePlateKernel ,parms);\n  }\n  else if(stringValue==\"ANOVA\"){\n    Kernel = KernelMatrix(datMat, predMat, ANOVAKernel ,parms);\n  }\n  else if(stringValue==\"Spline\"){\n    Kernel = KernelMatrix(datMat, predMat, SplineKernel ,parms);\n  }\n  else if(stringValue==\"Bessel\"){\n    Kernel = KernelMatrix(datMat, predMat, BesselKernel ,parms);\n  }\n  else if(stringValue==\"Arccos\"){\n    Kernel = KernelMatrix(datMat, predMat, ArccosKernel ,parms);\n  }\n\n  return(Kernel);\n}\n\n",
    "created" : 1477320315759.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "3424167185",
    "id" : "740E6A79",
    "lastKnownWriteTime" : 1477058763,
    "last_content_update" : 1477058763,
    "path" : "C:/Users/p.albuquerque/Dropbox/mlRFinance/src/KernelMatrix.cpp",
    "project_path" : "src/KernelMatrix.cpp",
    "properties" : {
        "tempName" : "Untitled1"
    },
    "relative_order" : 5,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "cpp"
}