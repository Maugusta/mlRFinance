{
    "collab_server" : "",
    "contents" : "#include <RcppArmadillo.h>\n#include <RcppEigen.h>\n// [[Rcpp::depends(RcppArmadillo)]]\n// [[Rcpp::depends(RcppEigen)]]\n#include <cmath>\nusing namespace Rcpp;\n/***************************************************************************************************************************/\n/*********************************                      UTILS          *****************************************************/\n/***************************************************************************************************************************/\nvoid PrintObjectLine(arma::vec mat){\n  int nelem=mat.n_elem;\n  for(int i=0;i<nelem;i++){\n    std::cout<<mat(i)<<\" \";\n  }\n  std::cout<<std::endl;\n}\n\nvoid PrintObjectLine(arma::uvec mat){\n  for(int i=0;i<mat.n_elem;i++){\n    std::cout<<mat(i)<<\" \";\n  }\n  std::cout<<std::endl;\n}\n\n\nvoid PrintObject(Eigen::VectorXd mat){\n  for(int i=0;i<mat.size();i++){\n    std::cout<<mat(i)<<\" \";\n  }\n  std::cout<<std::endl;\n}\n\n//Print Object at Console\nvoid PrintObject(Eigen::MatrixXd mat){\n  for(int i=0;i<mat.cols();i++){\n    for(int j=0;j<mat.rows();j++){\n      std::cout<<mat(i,j)<<\"\\t\";\n    }\n    std::cout<<std::endl;\n  }\n}\n\n//Print Object at Console\nvoid PrintObject(arma::mat mat){\n  for(int i=0;i<mat.n_rows;i++){\n    for(int j=0;j<mat.n_cols;j++){\n      std::cout<<mat(i,j)<<\"\\t\";\n    }\n    std::cout<<std::endl;\n  }\n}\n\n\n//Print time\nvoid PrintTime(){\n  // current date/time based on current system\n  time_t now = time(0);\n  // convert now to string form\n  char* dt = ctime(&now);\n  std::cout << \"The local date and time is: \" << dt << std::endl;\n}\n\n//Identify if the matrix is Positive Definite\nbool IsPositiveDefinite(Eigen::MatrixXd mat){\n  //Set the result\n  bool res=false;\n  //Setting the tolerance\n  double tol=1e-08;\n  //Getting the eigenvalues\n  Eigen::EigenSolver<Eigen::MatrixXd> es(mat,true);\n  for(int i=0;i<mat.rows();i++){\n    //Casting to complex\n    std::complex<double> lambda = es.eigenvalues()[i];\n    if (std::abs(lambda.real()) < tol) {\n      lambda.real(0);\n    }\n    else{\n      if(lambda.real()<0){\n        return(true);\n      }\n    }\n  }\nreturn(res);\n}\n\n\n//Adding some noise to diagonal\nvoid addNoise(Eigen::MatrixXd &mat,double noise){\n  //Create some perturbation\n  Eigen::VectorXd me1(mat.cols());\n  me1.fill(noise);\n  //Adding the noise\n  Eigen::MatrixXd mI1 = me1.asDiagonal();\n  mat=mat+mI1;\n}\n\n\n//Construct the the nearest positive semidefinite matrix in terms of Frobenius norm\n//Higham, Nicholas J. \"Computing a nearest symmetric positive semidefinite matrix.\"\n//Linear algebra and its applications 103 (1988): 103-118.\nvoid nearPositiveDefinite(Eigen::MatrixXd &mat,double noise){\n  //Set the result\n  bool res=false;\n  //Setting the tolerance\n  double tol=1e-08;\n  //Getting the eigenvalues\n  Eigen::EigenSolver<Eigen::MatrixXd> es(mat,true);\n  Eigen::MatrixXcd Lambda = es.eigenvalues().asDiagonal();\n  //Real part\n  Eigen::MatrixXd rLambda = Lambda.real();\n  for(int i=0;i<mat.cols();i++){\n   if(rLambda(i,i)<tol){\n     rLambda(i,i)=noise;\n    }\n  }\n  //Spectral Decomposition\n  mat = es.eigenvectors().real()*rLambda*es.eigenvectors().real().inverse();\n}\n\n\n/*\nvoid removeRow(Eigen::MatrixXd& matrix, unsigned int rowToRemove)\n{\n  unsigned int numRows = matrix.rows()-1;\n  unsigned int numCols = matrix.cols();\n\n  if( rowToRemove < numRows )\n    matrix.block(rowToRemove,0,numRows-rowToRemove,numCols) = matrix.block(rowToRemove+1,0,numRows-rowToRemove,numCols);\n\n  matrix.conservativeResize(numRows,numCols);\n}\n\nvoid removeColumn(Eigen::MatrixXd& matrix, unsigned int colToRemove)\n{\n  unsigned int numRows = matrix.rows();\n  unsigned int numCols = matrix.cols()-1;\n\n  if( colToRemove < numCols )\n    matrix.block(0,colToRemove,numRows,numCols-colToRemove) = matrix.block(0,colToRemove+1,numRows,numCols-colToRemove);\n\n  matrix.conservativeResize(numRows,numCols);\n}\n\n\nEigen::VectorXi compareGreat(Eigen::VectorXd d,double e1){\n  Eigen::VectorXi v(d.size());\n  for(int i=0;i<d.size();i++){\n    if(d(i)>e1){\n      v(i)=1; //True\n    }\n    else{\n      v(i)=0; //False\n    }\n  }\n  return(v);\n}\n\nEigen::MatrixXd removeColumns(Eigen::MatrixXd matrix, Eigen::VectorXi colToRemove)\n{\n  int col = colToRemove.sum();\n  int cont = 0;\n  Eigen::MatrixXd matrix0(matrix.rows(),col);\n  for(int c=0;c<matrix.cols();c++){\n    if(colToRemove(c)==1){\n      for(int r=0;r<matrix.rows();r++){\n            matrix0(r,cont)=matrix(r,c);\n      }\n      cont=cont+1;\n    }\n  }\n  return(matrix0);\n}\n\nvoid nearPDefinite(Eigen::MatrixXd &mat, int maxit, double eigtol = 1e-06){\n  int n = mat.cols();\n  Eigen::MatrixXd D_S = Eigen::MatrixXd::Zero(mat.rows(),mat.cols());\n  Eigen::MatrixXd X =mat;\n  int iter = 0;\n  bool converged = false;\n  double conv = std::numeric_limits<double>::infinity();\n  while (iter < maxit && !converged) {\n    Eigen::MatrixXd Y = X;\n    Eigen::MatrixXd R = Y - D_S;\n    //Getting the eigenvalues\n    Eigen::EigenSolver<Eigen::MatrixXd> e(R,true);\n    Eigen::MatrixXd Q = e.eigenvectors().real();\n    Eigen::VectorXd d = e.eigenvalues();\n    double e1 = eigtol*d(1);\n    Eigen::VectorXi p = compareGreat(d,e1);\n    bool test = (p.array() > 0).any();\n    if (!test){\n      stop(\"Matrix seems negative semi-definite\")\n    }\n    Eigen::MatrixXd Q0 = removeColumns(Q,p);\n    Eigen::VectorXd d0 = removeElements(d,p);\n    Eigen::MatrixXd Qtemp\n    X <- tcrossprod(Q0 * rep(d[p], each = nrow(Q0)), Q0)\n      if (doDykstra)\n        D_S <- X - R\n        if (doSym)\n          X <- (X + t(X))/2\n        if (corr)\n          diag(X) <- 1\n        else if (keepDiag)\n          diag(X) <- diagX0\n        conv <- norm(Y - X, conv.norm.type)/norm(Y, conv.norm.type)\n        iter <- iter + 1\n        if (trace)\n          cat(sprintf(\"iter %3d : #{p}=%d, ||Y-X|| / ||Y||= %11g\\n\",\n                      iter, sum(p), conv))\n        converged <- (conv <= conv.tol)\n  }\n  if (do2eigen || only.values) {\n    e <- eigen(X, symmetric = TRUE)\n    d <- e$values\n    Eps <- posd.tol * abs(d[1])\n    if (d[n] < Eps) {\n      d[d < Eps] <- Eps\n      if (!only.values) {\n        Q <- e$vectors\n        o.diag <- diag(X)\n        X <- Q %*% (d * t(Q))\n        D <- sqrt(pmax(Eps, o.diag)/diag(X))\n        X[] <- D * X * rep(D, each = n)\n      }\n    }\n  }\n  return(X);\n}\n*/\n",
    "created" : 1477072240290.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "2455843766",
    "id" : "957893B0",
    "lastKnownWriteTime" : 1477316044,
    "last_content_update" : 1477316044668,
    "path" : "C:/Users/p.albuquerque/Dropbox/mlRFinance/src/Utils.cpp",
    "project_path" : "src/Utils.cpp",
    "properties" : {
        "tempName" : "Untitled1"
    },
    "relative_order" : 3,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "cpp"
}