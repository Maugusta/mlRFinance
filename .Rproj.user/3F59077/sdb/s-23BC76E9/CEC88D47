{
    "collab_server" : "",
    "contents" : "#include <RcppArmadillo.h>\n#include <RcppEigen.h>\n#include \"eiquadprog.h\"\n#include \"KernelMatrix.h\"\n#include \"Utils.h\"\n// [[Rcpp::depends(RcppArmadillo)]]\n// [[Rcpp::depends(RcppEigen)]]\n#include <cmath>\nusing namespace Rcpp;\n\n/***********************************************************************************************/\n/*********************************    HEADER FUNCTIONS  ****************************************/\n/***********************************************************************************************/\n\n//Define the KernelMatrix function\nEigen::MatrixXd KernelMatrixComputation(Eigen::MatrixXd datMat,\n                                        std::string stringValue,\n                                        arma::vec parms);\nEigen::MatrixXd KernelMatrixComputationPred(Eigen::MatrixXd datMat,\n                                        Eigen::RowVectorXd predMat,\n                                        std::string stringValue,\n                                        arma::vec parms);\n//Define the Solver for Quadratic Programming\nEigen::VectorXd rcppeigen_quadratic_solve(Eigen::MatrixXd & G,\n                                          Eigen::VectorXd & g0,\n                                          const Eigen::MatrixXd & CE,\n                                          const Eigen::VectorXd & ce0,\n                                          const Eigen::MatrixXd & CI,\n                                          const Eigen::VectorXd & ci0);\n//Test if the matrix is Positive Definite\nbool IsPositiveDefinite(Eigen::MatrixXd mat);\n//nearest positive semidefinite matrix in terms of Frobenius norm\nvoid nearPositiveDefinite(Eigen::MatrixXd &mat,double noise);\n//Add some noise to the matrix diagonal\nvoid addNoise(Eigen::MatrixXd &mat,double noise);\n//Print Object at Console\nvoid PrintObject(Eigen::MatrixXd mat);\nvoid PrintObject(Eigen::VectorXd vec);\n\n\n/***********************************************************************************************/\n/*********************************     SVR FUNCTIONS    ****************************************/\n/***********************************************************************************************/\n\n//' @name CSVRL1\n//' @title C-SVR L1 - Support Vector Regression with C cost and L1 regularization.\n//' @description Optimize the Lagrange multiplier for the C-SVR L1:\n//'\n//' Min (1/2)u^{t}Qu+g^{t}u\n//' s.t.\n//' 0<=u<=C1\n//'\n//' where u=(lambda*,lambda), g=(e-y,e+y)\n//' and Q=|K -K|.\n//'       |-K K|\n//' C is the Cost parameter and e (epsilon) is the insentitive band\n//'\n//' @param y Vector with dependent variables. Dimension equal Nx1.\n//' @param X Numeric matrix with the explanatory variables. Dimension equal NxP\n//' @param C Cost parameter. Should be C>0.\n//' @param epsilon Insentitive band. Should be epsilon>0.\n//' @param kernel Name of the kernel that will be used.\n//' @param parms Parameters associated with chosen kenel.\n//' @return List Support Vectors, Kernel used and parameters.\n//' If the results for the Support Vectors are NaN it means that\n//' there is no Support Vector and the Quadratic Programming Problem\n//' is unfeasible.\n//' @examples\n//'\n//' A<-matrix(c(1,2,5,6,\n//' 2,4,1,2),nrow=4,ncol=2)\n//' d<-c(-1,-1,+1,-1)\n//' svm1<- CSVML1(d, A, 1, 0.1, \"Gaussian\", c(0.5))\n//'\n//' @seealso See \\code{\\link{.CallOctave}}, \\code{\\link{o_source}}, \\code{\\link{o_help}}\n// @cite soman2009machine\n// @bibliography ~/vignettes/bibliography.bib\n// [[Rcpp::export]]\nRcpp::List CSVRL1(Eigen::VectorXd y, Eigen::MatrixXd X, double C, double epsilon, std::string kernel, arma::vec parms){\n  //Support Vectors\n  Eigen::VectorXd SV(2*y.size());\n  //Create the one vector 2Nx1\n  Eigen::VectorXd yfull = Eigen::VectorXd(2*y.size());\n  yfull<< (-1.0)*y, (+1.0)*y;\n  Eigen::VectorXd evec = Eigen::VectorXd(2*y.size());\n  evec.fill(epsilon);\n  Eigen::VectorXd g = Eigen::VectorXd(2*y.size());\n  g = evec+yfull;\n  //RHS equality\n  Eigen::VectorXd ce0;\n  //LHS equality\n  Eigen::MatrixXd CE;\n  //RHS: Inequality 1\n  Eigen::VectorXd ci1 = Eigen::VectorXd::Zero(2*y.size());\n  //LHS: Inequality 1\n  Eigen::MatrixXd CI1 = Eigen::MatrixXd::Identity(2*y.size(),2*y.size());\n  //RHS: Inequality 2\n  Eigen::VectorXd ci2(2*y.size());\n  ci2.fill(C);\n  //Append RHS\n  Eigen::VectorXd ci0(4.0*y.size());\n  ci0 << ci1, ci2;\n  //Append LHS\n  Eigen::MatrixXd CI(CI1.rows()+CI1.rows(), CI1.cols());\n  //Diagonal matrix\n  Eigen::VectorXd me(2*y.size());\n  me.fill(-1.0);\n  Eigen::MatrixXd mI = me.asDiagonal();\n  //Vertical concatenation\n  CI << CI1,\n        mI;\n  //Create the Kernel Matrix\n  Eigen::MatrixXd K = KernelMatrixComputation(X,kernel,parms);\n  //Create matrix Q\n  Eigen::MatrixXd Q = Eigen::MatrixXd(2*y.size(),2*y.size());\n  Q<< K,-K,\n     -K, K;\n  //Nearest positive semidefinite matrix in terms of Frobenius norm\n  nearPositiveDefinite(Q,1e-10);\n  //Get the solution Support Vectors\n  SV = rcppeigen_quadratic_solve(Q,g, CE.transpose(),ce0, CI.transpose(), ci0);\n  //Return the results\n  return Rcpp::List::create(Rcpp::Named(\"SupportVectors\") = SV,\n                            Rcpp::Named(\"Kernel\") = kernel,\n                            Rcpp::Named(\"Parameters\") = parms);\n}\n\n\n//' @name Predicted CSVRL1\n//' @title C-SVR L1 - Support Vector Regression with C cost and L1 regularization.\n//' @description Prediction for the C-SVR L1:\n//'\n//' f(x)=Sum_{i=1}^{N}(lambda*-lambda)K(x_{i},x)\n//' @param CSVRL1 List of Results of the CSVRL1\n//' @param X Numeric matrix with the explanatory variables. Dimension equal NxP\n//' @param Xprev Numeric matrix with the explanatory variables (predicted). Dimension equal MxP\n//' @param kernel Name of the kernel that will be used.\n//' @param parms Parameters associated with chosen kenel.\n//' @return Eigen::VectorXd with the predicted values for Xpred\n//' @examples\n//'\n//' A<-matrix(c(1,2,5,6,\n//' 2,4,1,2),nrow=4,ncol=2)\n//' d<-c(-1,-1,+1,-1)\n//' svm1<- CSVML1(d, A, 1, 0.1, \"Gaussian\", c(0.5))\n//'\n//' @seealso See \\code{\\link{.CallOctave}}, \\code{\\link{o_source}}, \\code{\\link{o_help}}\n// @cite soman2009machine\n// @bibliography ~/vignettes/bibliography.bib\n// [[Rcpp::export]]\nEigen::VectorXd PredictedCSVRL1(Rcpp::List CSVRL1, Eigen::MatrixXd X, Eigen::MatrixXd Xprev, std::string kernel, arma::vec parms){\n  //Get the SV\n  Eigen::VectorXd SV = as<Eigen::VectorXd> (CSVRL1[\"SupportVectors\"]);\n  //Total number of observations\n  int size = Xprev.rows();\n  Eigen::VectorXd predVec(size);\n  //Separating the SV\n  Eigen::VectorXd diffLambda = SV.head(X.rows()) - SV.tail(X.rows());\n\n  for(int i=0;i<size;i++){\n    //Create the Kernel Matrix\n    Eigen::VectorXd K = KernelMatrixComputationPred(X,Xprev.row(i),kernel,parms);\n    Eigen::VectorXd F = diffLambda.array() *K.array();\n    predVec(i) = F.sum();\n  }\nreturn(predVec);\n}\n\n\n//' @param y Vector with dependent variables. Dimension equal Nx1.\n//' @param X Numeric matrix with the explanatory variables. Dimension equal NxP\n//' @param epsilon Insentitive band. Should be epsilon>0.\n//' @param kernel Name of the kernel that will be used.\n//' @param parms Parameters associated with chosen kenel.\n\n// [[Rcpp::export]]\nEigen::MatrixXd minimumCSVRL1(Eigen::VectorXd y, Eigen::MatrixXd X, double epsilon, std::string kernel, arma::vec parms){\n  Eigen::VectorXd SV(2*y.size());\n  //Create the one vector 2Nx1\n  Eigen::VectorXd yfull = Eigen::VectorXd(2*y.size());\n  yfull<< (-1.0)*y, (+1.0)*y;\n  Eigen::VectorXd evec = Eigen::VectorXd(2*y.size());\n  evec.fill(epsilon);\n  Eigen::VectorXd g = Eigen::VectorXd(2*y.size());\n  g = evec+yfull;\n  //Create the Kernel Matrix\n  Eigen::MatrixXd K = KernelMatrixComputation(X,kernel,parms);\n  //Create matrix Q\n  Eigen::MatrixXd Q = Eigen::MatrixXd(2*y.size(),2*y.size());\n  Q<< K,-K,\n     -K, K;\n  //Nearest positive semidefinite matrix in terms of Frobenius norm\n\n//  nearPositiveDefinite(Q,1e-10);\n//  std::cout<<Q<<std::endl;\n  //Calculate the Minimum Objective function\n  SV = -Q.inverse()*g;\n  return(Q);\n}\n",
    "created" : 1477065517565.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "294437378",
    "id" : "CEC88D47",
    "lastKnownWriteTime" : 1477073584,
    "last_content_update" : 1477073584571,
    "path" : "C:/Users/p.albuquerque/Dropbox/mlRFinance/src/SVR.cpp",
    "project_path" : "src/SVR.cpp",
    "properties" : {
        "tempName" : "Untitled1"
    },
    "relative_order" : 2,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "cpp"
}