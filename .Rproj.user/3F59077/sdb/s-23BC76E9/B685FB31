{
    "collab_server" : "",
    "contents" : "#include <RcppArmadillo.h>\n// [[Rcpp::depends(RcppArmadillo)]]\n#include <cmath>\nusing namespace Rcpp;\n\n\n/********************************************************************************************************/\n/***********************************         KERNEL FUNCTIONS      **************************************/\n/********************************************************************************************************/\n//https://github.com/accord-net/framework/blob/development/Sources/Accord.Statistics/Kernels/Gaussian%601.cs\n//http://crsouza.com/2010/03/17/kernel-functions-for-machine-learning-applications/\n//http://cseweb.ucsd.edu/~yoc002/arccos.html\n\n\ndouble ArccosKernel(arma::vec x,arma::vec y,arma::vec parms)\n{\n  double k_xx_l = arma::sum(x % y);\n  double k_yy_l = arma::sum(y % y);\n  double k_xy_l = arma::sum(x % y);\n  double theta_l;\n\n  int L = parms.size();\n\n  for (int l=1; l<=L; l++)\n  {\n    theta_l = std::acos(std::max(std::min(k_xy_l / std::sqrt(k_xx_l * k_yy_l),  1.0), -1.0));\n    k_xy_l = std::pow(k_xx_l * k_yy_l, parms[l-1]/2) / M_PI * R::bessel_j(parms[l-1], theta_l);\n    if (l < L)\n    {\n      k_xx_l  = std::pow(k_xx_l, parms[l-1]) / M_PI * R::bessel_j(parms[l-1], 0);\n      k_yy_l  = std::pow(k_yy_l, parms[l-1]) / M_PI * R::bessel_j(parms[l-1], 0);\n    }\n  }\n  return k_xy_l;\n}\n\ndouble BesselKernel(arma::vec x,arma::vec y,arma::vec parms)\n{\n  double res;\n  double order = parms(0);\n  double degree= parms(1);\n  double sigma = parms(3);\n  double lim = 1.0/(R::gammafn(order+1.0)*std::pow(2.0,order));\n  double comp = -1.0*(2*arma::sum(x % y) - arma::sum(x % x) - arma::sum(y % y));\n  double bkt =  sigma*std::sqrt(comp);\n  if(bkt < 10e-5){\n    res = lim;\n  }\n  else{\n      res = R::bessel_j(bkt,order)*(std::pow(bkt,(-order)));\n  }\n  return res;\n}\n\n\ndouble ThinSplinePlateKernel(arma::vec x,arma::vec y,arma::vec parms)\n{\n  double sigma=parms(0);\n  double r = 0;\n  for (int i=0;i<x.n_elem;i++)\n  {\n    double dxy = x(i) - y(i);\n    r += dxy * dxy;\n  }\n\n  return r / (sigma * sigma) * std::log(std::sqrt(r) / sigma);\n}\n\ndouble SymmetricTriangleKernel(arma::vec x,arma::vec y,arma::vec parms)\n{\n  double gamma=parms(0);\n  double norm = 0.0;\n  for (int i=0;i<x.n_elem;i++)\n  {\n    double d = x(i) - y(i);\n    norm += d * d;\n  }\n\n  double z = 1.0 - gamma * std::sqrt(norm);\n\n  return (z > 0) ? z : 0;\n}\n\ndouble SquaredSincKernel(arma::vec x,arma::vec y,arma::vec parms)\n{\n  double norm = 0.0;\n  double gamma=parms(0);\n\n  for (int i=0;i<x.n_elem;i++)\n  {\n    double d = x(i) - y(i);\n    norm += d * d;\n  }\n\n  double num = gamma * std::sqrt(norm);\n  double den = gamma * gamma * norm;\n\n  return std::sin(num) / den;\n}\n\ndouble SigmoidKernel(arma::vec x,arma::vec y,arma::vec parms)\n{\n  double alpha=parms(0);\n  double constant=parms(1);\n  double sum = 0.0;\n  for (int i=0;i<x.n_elem;i++)\n    sum += x(i) * y(i);\n  double value = std::tanh(alpha * sum + constant);\n\n  return value;\n}\n\ndouble PearsonKernel(arma::vec x,arma::vec y,arma::vec parms)\n{\n  double constant=parms(0);\n  double omega=parms(1);\n\n  //Inner product\n  double xx = 0;\n  double yy = 0;\n  double xy = 0;\n  for (int i=0;i<x.n_elem;i++)\n  {\n    double u = x(i) * x(i);\n    double v = y(i) * y(i);\n    double uv = x(i) * y(i);\n    xx += u;\n    yy += v;\n    xy += uv;\n  }\n\n  double m = constant * std::sqrt(-2.0 * xy + xx + yy);\n  return 1.0 / std::pow(1.0 + m * m, omega);\n}\n\ndouble DirichletKernel(arma::vec x,arma::vec y,arma::vec parms)\n{\n  double N=parms(0);//Dimension\n  double delta=parms(1);\n  double prod = 1;\n  for (int i=0;i<x.n_elem;i++)\n  {\n    double delta = x(i) - y(i);\n    double num = std::sin((N + 0.5) * (delta));\n    double den = 2.0 * std::sin(delta / 2.0);\n    prod *= num / den;\n  }\n\n  return prod;\n}\n\ndouble HellingerKernel(arma::vec x,arma::vec y,arma::vec parms)\n{\n  double r = 0;\n  r=arma::sum(arma::sqrt(x*y));\n  return r;\n}\n\ndouble WaveKernel(arma::vec x,arma::vec y,arma::vec parms)\n{\n  double norm = arma::norm(x-y);\n  double sigma=parms(0);\n\n  if (sigma == 0 || norm == 0)\n    return 0;\n\n  return (sigma / norm) * std::sin(norm / sigma);\n}\n\ndouble LogKernel(arma::vec x,arma::vec y,arma::vec parms)\n{\n  double a=parms(0);\n  double b=parms(1);\n  double norm = arma::norm(x-y);\n  double res=-1.0*std::log(std::pow(norm,a)+b);\n  return(res);\n}\n\ndouble SphericalKernel(arma::vec x,arma::vec y,arma::vec parms)\n{\n  double sigma=parms(0);\n  double norm = arma::norm(x-y);\n  double res=0;\n  if(norm>=sigma){\n    res=1.0-1.5*(norm/sigma)+0.5*std::pow(norm/sigma,3);\n  }\n  return(res);\n}\n\ndouble CircularKernel(arma::vec x,arma::vec y,arma::vec parms)\n{\n  double sigma=parms(0);\n  double norm = arma::norm(x-y);\n  double res=0;\n  if(norm>=sigma){\n    res=(2.0/M_PI)*std::acos(-norm/sigma)-(2.0/M_PI)*(norm/sigma)*std::sqrt(1-std::pow((norm/sigma),2));\n  }\n  return(res);\n}\n\n//Only for positive values in X and Y\ndouble HistogramIntersectionKernel(arma::vec x,arma::vec y,arma::vec parms)\n{\n  double sum=0;\n  for(int i=0;i<x.n_elem;i++){\n    sum=sum+std::min(x(i),y(i));\n  }\n  return(sum);\n}\n\ndouble GeneralizedHistogramIntersectionKernel(arma::vec x,arma::vec y,arma::vec parms)\n{\n  double a=parms(0);\n  double b=parms(1);\n  double sum=0;\n  for(int i=0;i<x.n_elem;i++){\n    sum=sum+std::min(std::pow(std::abs(x(i)),a),std::pow(std::abs(y(i)),b));\n  }\n  return(sum);\n}\n\ndouble CauchyKernel(arma::vec x,arma::vec y,arma::vec parms)\n{\n  double sigma = parms(0);\n  double den=1+((arma::sum(arma::square(x-y)))/(std::pow(sigma,2)));\n  double res=1/den;\n  return(res);\n}\n\ndouble PolynomialKernel(arma::vec x,arma::vec y,arma::vec parms)\n{\n  double a=parms(0);\n  double b=parms(1);\n  double num=arma::dot(x,y);\n  double res=std::pow(num+b,a);\n  return(res);\n}\n\n\n\ndouble ChiSquareKernel(arma::vec x,arma::vec y,arma::vec parms)\n{\n  arma::vec num=arma::square(x-y);\n  arma::vec den= 0.5*(x+y);\n  double res=1.0-arma::sum(num/den);\n  return(res);\n}\n\ndouble ExponentialKernel(arma::vec x,arma::vec y,arma::vec parms)\n{\n  double sigma = parms(0);\n  double num = std::sqrt(arma::sum(arma::square(x-y)));\n  double den=2*(std::pow(sigma,2));\n  double res=(-(num/den));\n  return(res);\n}\n\n\ndouble GaussianKernel(arma::vec x,arma::vec y, arma::vec parms)\n{\n  double sigma = parms(0);\n  double num = -1.0*std::pow(arma::norm(x-y),2);\n  double den=2*(std::pow(sigma,2));\n  double res=std::exp((num/den));\n  return(res);\n}\n\ndouble GeneralizedTStudentKernel(arma::vec x,arma::vec y,arma::vec parms)\n{\n  double d = parms(0);\n  double res=1.0/(1.0+(std::pow(std::sqrt(arma::sum(arma::square(x-y))),d)));\n  return(res);\n}\n\ndouble HyperbolicTangentKernel(arma::vec x,arma::vec y,arma::vec parms)\n{\n  double n=parms(0);\n  double cc=parms(1);\n  double cross = arma::sum(x % y);\n  double res=tanh(((1.0/n)*cross)+cc);\n  return(res);\n}\n\ndouble SplineKernel(arma::vec x,arma::vec y,arma::vec parms)\n{\n  double prod=1;\n  for(int i=0;i<x.size();i++){\n    double res=1+(x(i)*y(i)*std::min(x(i),y(i)))-((x(i)+y(i))/2.0)*(std::pow(std::min(x(i),y(i)),2)+(std::pow(std::min(x(i),y(i)),3)/3.0));\n    prod=prod*res;\n  }\n  return(prod);\n}\n\ndouble ANOVAKernel(arma::vec x,arma::vec y,arma::vec parms)\n{\n  double sigma=parms(0);\n  double d=parms(1);\n  arma::vec diff=arma::exp(-sigma*arma::square(x-y));\n  double res=std::pow(arma::sum(diff),d);\n  return(res);\n}\n\ndouble InverseMultiquadraticKernel(arma::vec x,arma::vec y,arma::vec parms)\n{\n  double cc=parms(0);\n  double res=1.0/(std::sqrt(arma::sum(arma::square(x-y))+(std::pow(cc,2))));\n  return(res);\n}\n\ndouble LaplacianoKernel(arma::vec x,arma::vec y,arma::vec parms)\n{\n  double sigma=parms(0);\n  double num=std::sqrt(arma::sum(arma::square(x-y)));\n  double den=sigma;\n  double res = std::exp(-1.0*(num/den));\n  return(res);\n}\n\ndouble LinearKernel(arma::vec x,arma::vec y,arma::vec parms)\n{\n  double cc=parms(0);\n  double cross = arma::sum(x % y);\n  double res = cross+cc;\n  return(res);\n}\n\ndouble LogLinearKernel(arma::vec x,arma::vec y,arma::vec parms)\n{\n  double d=parms(0);\n  double res = (-1.0*std::log(std::pow(std::sqrt(arma::sum(arma::square(x-y))),d)+1.0));\n  return(res);\n}\n\ndouble MultiquadraticKernel(arma::vec x,arma::vec y,arma::vec parms)\n{\n  double cc=parms(0);\n  double res = std::sqrt(arma::sum(arma::square(x-y))+(std::pow(cc,2)));\n  return(res);\n}\n\ndouble PowerKernel(arma::vec x,arma::vec y,arma::vec parms)\n{\n  double d=parms(0);\n  double res = (-1.0*std::pow(std::sqrt(arma::sum(arma::square(x-y))),d));\n  return(res);\n}\n\n\ndouble RationalQuadraticKernel(arma::vec x,arma::vec y,arma::vec parms)\n{\n  double cc=parms(0);\n  double num=arma::sum(arma::square(x-y));\n  double den=arma::sum(arma::square(x-y))+cc;\n  double res = 1.0-(num/den);\n  return(res);\n}\n\ndouble WaveletKernel(arma::vec x,arma::vec y,arma::vec parms)\n{\n  double a=parms(0);\n  arma::vec hx1=((x-y)/a);\n  arma::vec res = arma::cos(1.75*hx1)*arma::exp(-1.0*((arma::square(hx1)/2.0)));\n  double res2=1;\n    for(int i=0;i<res.n_elem;i++){\n      res2=res2*res(i);\n    }\n  return(res2);\n}\n\ndouble MexicanHatKernel(arma::vec x,arma::vec y,arma::vec parms)\n{\n  double a=parms(0);\n  double res2 = arma::prod((1.0-arma::square(x-y)/std::pow(a,2))*arma::exp(-arma::square(x-y)/(2.0*std::pow(a,2))));\n  return(res2);\n}\n\ndouble MorletKernel(arma::vec x,arma::vec y,arma::vec parms)\n{\n  double a=parms(0);\n  double res2 = arma::prod(arma::cos(5.0*(x-y)/a)*arma::exp(-arma::square(x-y)/(2.0*std::pow(a,2))));\n  return(res2);\n}\n",
    "created" : 1477320310509.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "719156840",
    "id" : "B685FB31",
    "lastKnownWriteTime" : 1476991119,
    "last_content_update" : 1476991119,
    "path" : "C:/Users/p.albuquerque/Dropbox/mlRFinance/src/KernelComputation.cpp",
    "project_path" : "src/KernelComputation.cpp",
    "properties" : {
        "tempName" : "Untitled1"
    },
    "relative_order" : 4,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "cpp"
}